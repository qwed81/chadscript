fn or(int a, int b) int
  include
    return a | b;
  return a

struct err
  str message

fn err(str message) err
  return { message = message }

enum TypeUnion[T, K]
  T val0
  K val1

struct range
  int start
  int end

fn next(&range r) int|nil
  int thisIndex = r.start
  if r.start == r.end
    return nil
  r.start += 1
  return thisIndex

fn rev(range r) revRange
  return { start = r.end - 1, end = r.start - 1 }

struct revRange
  int start
  int end

fn next(&revRange r) int|nil
  int thisIndex = r.start
  if r.start == r.end
    return nil
  r.start -= 1
  return thisIndex

fn alloc(int amt) *T
  *T output
  include
    _output = malloc(sizeof($(T)) * *_amt);
  return output

fn null() *T
  include
    return NULL;
  return null()

fn ptrCast(*S input) *E
  include
    return ($(*E))(*_input);
  return ptrCast(input)

struct Arr[T]
  get *T base
  get int capacity
  get int len

fn arr() Arr[T]
  return { base = alloc(4), capacity = 4, len = 0 }

fn arr(int amt) Arr[T]
  return { base = alloc(amt), capacity = amt, len = amt }

fn str(Arr[T] l, str(T) strImpl=str) str
  Fmt buf = fmt()
  buf += "["
  for i in 0:l.len
    buf += strImpl(l[i])
    if i != l.len - 1
      buf += ','
  buf += ']'
  return str(buf)

fn prepareIndex(&Arr[T] l, int index, T val) *T
  assert index >= 0 && index < l.len
  return ptr(l.base[index])

fn getIndex(&Arr[T] l, int index) *T
  assert index >= 0 && index < l.len
  return ptr(l.base[index])

fn prepareIndex(&Arr[T] l, i32 index, T val) *T
  int intIndex = int(index)
  assert intIndex >= 0 && intIndex < l.len
  return ptr(l.base[intIndex])

fn getIndex(&Arr[T] l, i32 index) *T
  int intIndex = int(index)
  assert intIndex >= 0 && intIndex < l.len
  return ptr(l.base[intIndex])

fn getIndex(&Arr[T] l, range r) *Arr[T]
  assert r.start >= 0 && r.end <= l.len
  *Arr[T] newList = alloc(1)
  int len = r.end - r.start
  newList[0] = { base = ptr(l.base[r.start]), capacity = len, len = len }
  return newList

fn append(&Arr[T] l, T val)
  if l.len == l.capacity
    *T newAlloc = alloc(l.capacity * 2)

    for i in 0:l.len
      newAlloc[i] = cp l.base[i]
    l.base = newAlloc
    l.capacity = l.capacity * 2

  l.base[l.len] = cp val
  l.len += 1

fn append(&Arr[T] to, Arr[T] from)
  for i in 0:from.len
    to += from[i]

struct str
  get *char base
  get int len

fn str(str s) str
  return s

fn eq(str a, str b) bool
  if a.len != b.len
    return false
  for i in 0:a.len
    if a[i] != b[i]
      return false
  return true

fn getIndex(&str s, int index) *char
  assert index >= 0 && index < s.len
  return ptr(s.base[index])

fn getIndex(&str s, range r) *str
  assert r.start >= 0 && r.end <= s.len
  *str newStr = alloc(1)
  int len = r.end - r.start
  newStr[0] = { base = ptr(s.base[r.start]), len = len }
  return newStr

fn cstr(str s) *char
  *char cstr = alloc(s.len + 1)
  for i in 0:s.len
    cstr[i] = s[i]
  return cstr

fn split(str s) Arr[str]
  return split(s, ' ')

fn split(str s, char c) Arr[str]
  Arr[str] output = []

  int end = 0
  int start = 0
  while true
    if end >= s.len 
      break
    if s[end] == c
      output += s[start:end]
      start = end + 1
    end += 1
  output += s[start:s.len]
  return output

fn trim(str s) str
  return ""

fn contains(str s, str inner) bool
  return false

fn startsWith(str s, str start) bool
  return false

fn endsWith(str s, str end) bool
  return false

fn indexOf(str s, str inner) int|nil
  return nil

fn lastIndexOf(str s, str inner) int|nil
  return nil

struct Fmt
  get *char base
  get int capacity
  get int len

fn fmt() Fmt
  return { base = alloc(8), capacity = 8, len = 0 }

fn fmt(int size) Fmt
  return { base = alloc(size), capacity = size, len = size }

fn clone(Fmt buf) Fmt
  *char newBase = alloc(buf.len)
  for i in 0:buf.len
    newBase[i] = buf[i]
  return { base = newBase, capacity = buf.len, len = buf.len }

fn fromUtf8(Arr[byte] bytes) Fmt
  Fmt buf = fmt(bytes.len)
  for i in 0:bytes.len
    buf[i] = char(bytes[i])
  return buf

fn toUtf8(Fmt buf) Arr[byte]
  Arr[byte] bytes = arr(buf.len)
  for i in 0:buf.len
    bytes[i] = byte(buf[i])
  return bytes

fn fmt(str start) Fmt
  Fmt buf = fmt()
  append(buf, start)
  return buf

fn str(Fmt buf) str
  return { base = buf.base, len = buf.len }

fn appendOne(&Fmt s, char c)
  if s.len == s.capacity
    *char newAlloc = alloc(s.capacity * 2)

    for i in 0:s.len
      newAlloc[i] = s.base[i]
    s.base = newAlloc
    s.capacity = s.capacity * 2

  s.base[s.len] = c
  s.len += 1

fn append(&Fmt s, T val, str(T) strImpl=str)
  str valAsStr = strImpl(val)
  for i in 0:valAsStr.len
    appendOne(s, valAsStr[i])
  
fn prepareIndex(Fmt s, int index, T val) *char
  assert index >= 0 && index < s.len
  return ptr(s.base[index])

fn getIndex(&Fmt s, int index) *char
  assert index >= 0 && index < s.len
  return ptr(s.base[index])

fn getIndex(&Fmt s, range r) *Fmt
  assert r.start >= 0 && r.end <= s.len
  *Fmt newStr = alloc(1)
  int len = r.end - r.start
  newStr[0] = { base = ptr(s.base[r.start]), capacity = len, len = len }
  return newStr

struct Map[K, V]

struct Set[T]

struct Heap[T]

struct BST[T]

fn rand(int start, int end) int
  return 0

fn str(int val) str
  int len
  include
    _len = snprintf(NULL, 0, "%ld", *_val);

  *char output = alloc(len + 1)
  include
    snprintf(_output, _len + 1, "%ld", *_val);
  return { base = output, len = len }
  
fn print(T val, str(T) strImpl=str) 
  *char printStr = cstr(strImpl(val))
  include
    printf("%s\n", _printStr);

fn str(char val) str
  Fmt buf = fmt(1)
  buf[0] = val
  return str(buf)

fn char(byte val) char
  include 
    return (char)(*_val);
  return '\0'

fn byte(char val) byte
  include
    return ($(byte))(*_val);
  return byte('\0')

struct Scanner[T]
  Arr[byte] buf
  T stream
  TypeUnion[int, err](T, Arr[byte]) readBytes
  int amtInBuf
  int i

fn scanner(T stream, TypeUnion[int, err](T, Arr[byte]) r=read) Scanner[T]
  return { buf = arr(1024), stream = mv stream, readBytes = r, amtInBuf = 0, i = 0 }

fn nextLine(&Scanner[T] scanner) str|err
  Fmt output = fmt()

  while true
    if scanner.i == scanner.amtInBuf
      scanner.amtInBuf = try scanner.readBytes(scanner.stream, scanner.buf)
      scanner.i = 0
    if scanner.amtInBuf == 0
      return err("no next element")
    output += char(scanner.buf[scanner.i])
    scanner.i += 1
    if scanner.buf[scanner.i] == byte('\n')
      break

  return str(output)

fn str(i32 val) str
  return str(int(val))

fn int(i32 val) int
  include
    return ($(int))*_val;
  return 0

fn input(str output) int|err
  C.printf(cstr("%s"), cstr(output))
  int val = 0
  C.scanf(cstr("%ld"), ptr(val))
  return val

