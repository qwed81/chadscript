struct err
  str message

fn err(str message) err
  ret { message = message }

enum TypeUnion[T, K]
  T val0
  K val1

struct range
  int start
  int end
  int output

fn next(&range r) *int
  r.output = r.start
  if r.start == r.end
    ret nil
  r.start += 1
  ret &r.output

##
fn rev(range r) revRange
  ret { start = r.end - 1, end = r.start - 1, output = r.start - 1 }

struct revRange
  int start
  int end
  int output

fn next(&revRange r) *int
  int thisIndex = r.start
  if r.start == r.end
    ret nil
  r.start -= 1
  ret thisIndex
##

fn alloc(int amt) *T
  *T output
  include
    _output = malloc(sizeof($(T)) * *_amt);
  ret output

fn null() *T
  include
    ret NULL;
  ret null()

fn ptrCast(*S input) *E
  include
    ret ($(*E))(*_input);
  ret ptrCast(input)

struct Vec[T]
  get *T base
  get int capacity
  get int len

fn vec(int amt) Vec[T]
  ret { base = alloc(amt), capacity = amt, len = amt }

fn str(Vec[T] l, str(T) strImpl=str) str
  Fmt buf = fmt()
  buf ++= "["
  for i in 0:l.len
    buf ++= strImpl(l[i])
    if i != l.len - 1
      buf ++= ','
  buf ++= ']'
  ret str(buf)

fn append(&Vec[T] l, T val)
  if l.len == l.capacity
    *T newAlloc = alloc(l.capacity * 2)

    for i in 0:l.len
      newAlloc[i] = cp l.base[i]
    l.base = newAlloc
    l.capacity = l.capacity * 2

  l.base[l.len] = cp val
  l.len += 1

fn append(&Vec[T] to, Vec[T] from)
  for i in 0:from.len
    to ++= from[i]

struct str
  get *char base
  get int len

fn str(str s) str
  ret s

fn eq(str a, str b) bool
  if a.len != b.len
    ret false
  for i in 0:a.len
    if a[i] != b[i]
      ret false
  ret true

fn cstr(str s) *char
  *char cstr = alloc(s.len + 1)
  for i in 0:s.len
    cstr[i] = s[i]
  cstr[s.len] = '\0'
  ret cstr

fn split(str s) Vec[str]
  ret split(s, ' ')

fn split(str s, char c) Vec[str]
  Vec[str] output = []

  int end = 0
  int start = 0
  while true
    if end >= s.len 
      break
    if s[end] == c
      output ++= s[start:end]
      start = end + 1
    end += 1
  output ++= s[start:s.len]
  ret output

fn trim(str s) str
  ret ""

fn contains(str s, str inner) bool
  ret false

fn startsWith(str s, str start) bool
  ret false

fn endsWith(str s, str end) bool
  ret false

fn indexOf(str s, str inner) int|nil
  ret nil

fn lastIndexOf(str s, str inner) int|nil
  ret nil

struct Fmt
  get *char base
  get int capacity
  get int len

fn fmt() Fmt
  ret { base = alloc(8), capacity = 8, len = 0 }

fn fmt(int size) Fmt
  ret { base = alloc(size), capacity = size, len = size }

fn clone(Fmt buf) Fmt
  *char newBase = alloc(buf.len)
  for i in 0:buf.len
    newBase[i] = buf[i]
  ret { base = newBase, capacity = buf.len, len = buf.len }

fn fromUtf8(Vec[u8] bytes) Fmt
  Fmt buf = fmt(bytes.len)
  for i in 0:bytes.len
    buf[i] = char(bytes[i])
  ret buf

fn toUtf8(Fmt buf) Vec[u8]
  Vec[u8] bytes = vec(buf.len)
  for i in 0:buf.len
    bytes[i] = u8(buf[i])
  ret bytes

fn fmt(str start) Fmt
  Fmt buf = fmt()
  append(buf, start)
  ret buf

fn str(Fmt buf) str
  ret { base = buf.base, len = buf.len }

fn appendOne(&Fmt s, char c)
  if s.len == s.capacity
    *char newAlloc = alloc(s.capacity * 2)

    for i in 0:s.len
      newAlloc[i] = s.base[i]
    s.base = newAlloc
    s.capacity = s.capacity * 2

  s.base[s.len] = c
  s.len += 1

fn append(&Fmt s, T val, str(T) strImpl=str)
  str valAsStr = strImpl(val)
  for i in 0:valAsStr.len
    appendOne(s, valAsStr[i])

struct Map[K, V]

struct Set[T]

struct Heap[T]

struct BST[T]

fn rand(int start, int end) int
  include
    ret (*_end - *_start) * ((double)rand() / (double)RAND_MAX) + *_start;
  ret 0

fn rand() f64
  include
    ret ((double)rand() / (double)RAND_MAX);
  ret 0.0

fn str(int val) str
  int len
  include
    _len = snprintf(NULL, 0, "%ld", *_val);

  *char output = alloc(len + 1)
  include
    snprintf(_output, _len + 1, "%ld", *_val);
  ret { base = output, len = len }

fn str(f64 val) str
  int len
  include
    _len = snprintf(NULL, 0, "%lf", *_val);

  *char output = alloc(len + 1)
  include
    snprintf(_output, _len + 1, "%lf", *_val);
  ret { base = output, len = len }
  
fn print(T val, str(T) strImpl=str) 
  *char printStr = cstr(strImpl(val))
  include
    printf("%s\n", _printStr);

fn str(char val) str
  Fmt buf = fmt(1)
  buf[0] = val
  ret str(buf)

struct Scanner[T]
  Vec[u8] buf
  T stream
  TypeUnion[int, err](T, Vec[u8]) readBytes
  int amtInBuf
  int i

fn scanner(T stream, TypeUnion[int, err](T, Vec[u8]) r=read) Scanner[T]
  ret { buf = vec(1024), stream = mv stream, readBytes = r, amtInBuf = 0, i = 0 }

fn nextLine(&Scanner[T] scanner) str|err
  Fmt output = fmt()

  while true
    if scanner.i == scanner.amtInBuf
      scanner.amtInBuf = try scanner.readBytes(scanner.stream, scanner.buf)
      scanner.i = 0
    if scanner.amtInBuf == 0
      ret err("no next element")
    output ++= char(scanner.buf[scanner.i])
    scanner.i += 1
    if scanner.buf[scanner.i] == u8('\n')
      break

  ret str(output)

fn str(i32 val) str
  ret str(int(val))

fn input(str output) int|err
  C.printf(cstr("%s"), cstr(output))
  int val = 0
  C.scanf(cstr("%ld"), &val)
  ret val

enum Type
  str Basic
  *Type Ptr
  *TypeFn Fn
  *TypeStruct Struct
  *TypeStruct Enum

struct TypeFn
  get Vec[Type] params
  get Type retType
  get str name

struct TypeField
  get str name
  get Type type

struct TypeStruct
  get Vec[TypeField] fields
  get str name
