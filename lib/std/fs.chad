fn uv_err(int code) T!
  Fmt errMessage = fmt(1024)
  C.uv_err_name_r(code, errMessage.base, 1024)
  T! err = Err(str(errMessage))
  return err

pub fn mkDir(str srcPath) void!
  return Err("not implemented")

pub fn fsCp(str srcPath, str destPath) void!
  return Err("not implemented")

pub fn fsMv(str srcPath, str destPath) void!
  return Err("not implemented")

pub fn fsRm(str srcPath) void!
  return Err("not implemented")

pub enum FileFlags
  void Read
  void ReadWrite

pub struct File
  int handle
  bool alreadyClosed

fn drop(ln File file)
  close(file)

pub fn open(str path, FileFlags flags, bool createIfMissing=false) File!
  int fileHandle = -1
  int intFlags = 0

  int r = C.S_IRUSR
  int w = C.S_IWUSR
  int intMode = or(r, w)
  int intFlags = 0

  if flags is Read
    intFlags = C.UV_FS_O_RDONLY
  elif flags is ReadWrite
    intFlags = C.UV_FS_O_RDWR

  if createIfMissing
    int create = C.UV_FS_O_CREAT
    intFlags = or(intFlags, create)

  ptr[char] cPath = cstr(path)
  fileHandle = C.openFile(cPath, intFlags, intMode)
  if fileHandle < 0
    return uv_err(fileHandle)

  return { handle = fileHandle, alreadyClosed = false }

pub fn close(ln File file)
  if file.alreadyClosed
    return
  C.closeFile(file.handle)
  file.alreadyClosed = false

pub fn read(ln File file, ln Arr[byte] buf, int position=-1) int! amtRead
  int result = C.readFile(file.handle, buf.base, buf.len, position)
  if result < 0
    return uv_err(result)
  return result

pub fn write(ln File file, Arr[byte] bytes, int position=-1) void!
  int result = C.writeFile(file.handle, bytes.base, bytes.len, position)
  if result < 0
    return uv_err(result)

  return Ok

pub enum DirEntryType
  void File
  void Dir
  void Other

pub struct DirEntry
  get DirEntryType type
  get str name

pub fn readDir(str path) Arr[DirEntry]!
  int numEntries = 0
  int result = 0
  include
    ReadDirResult dirResult = readDir(_path->_base);
    _numEntries = dirResult.len;
    _result = dirResult.result;
  if result < 0 && result != -4095 # EOF
    return uv_err(result)

  Arr[DirEntry] entries = arr(numEntries) 
  for i in 0:numEntries
    int index = i
    int strLen
    include
      const char* filePath = dirResult.files[_index].name;
      _strLen = strlen(filePath);

    Fmt name = fmt(strLen)
    DirEntryType fileType = File
    include
      // copy the path into name
      memcpy(_name._base, filePath, _strLen);

      // set the fileType
      if (dirResult.files[_index].type == UV_DIRENT_FILE) {
        _fileType.tag = 0;
      }
      else if (dirResult.files[_index].type == UV_DIRENT_DIR) {
        _fileType.tag = 1;
      }
      else {
        _fileType.tag = 2;
      }

    entries[i] = { type = fileType, name = str(name) }

  return Ok(entries)
