use std

fn uv_err(int code) T!
  strbuf errMessage = strbuf(1024)
  include
    uv_err_name_r(*_code, _errMessage._base, 1024);
  T! err = Err(str(errMessage))

  return err

pub struct TcpSocket
  ptr[void] handle
  bool alreadyClosed

drop(TcpSocket& socket)
  close(socket);

struct TcpConnectionArgs[T]
  T args
  void!(TcpSocket, T) handler

tcpListenStart(int handle, TcpConnectionArgs[T] args)
  int streamHandle
  include
    _streamHandle = (int64_t)_handle;

  TcpSocket socket = { handle = streamHandle, alreadyClosed = false }
  void! result = args.handler(socket, args.args)
  close(socket)

pub listen(str host, int port, T args, void!(TcpSocket&, T) handler) void!
  str cHost = cstr(host)
  void(int, TcpConnectionArgs[T]) start = tcpListenStart
  int result
  include
    size_t size = sizeof($(TcpConnectionArgs[T]));
    $(TcpConnectionArgs[T])* item = malloc(size);
    item->_args = *_args;
    item->_handler = *_handler;

    _result = listenTcp(_cHost._start, *_port, item, (void*)_start);
    free(item);
  if result < 0
    return uv_err(result)

  return Ok

pub connect(str host, int port) TcpSocket!
  str cHost = cstr(host)
  int result
  int outHandle

  include
    _result = connectTcp(_cHost._start, *_port, (TcpHandle*)&_outHandle);
  if result < 0
    return uv_err(result)
  
  return { handle = outHandle, alreadyClosed = false }

pub read(TcpSocket& socket, list[byte] buf) int!
  int result
  include
    _result = readTcp((void*)_socket->_handle, _buf->_start, _buf->_len);
  if result < 0
    return uv_err(result)
  return result

pub write(TcpSocket& socket, list[byte] bytes) void!
  int result
  include
    _result = writeTcp((void*)_socket->_handle, _bytes->_start, _bytes->_len);
  if result < 0
    return uv_err(result)
  return Ok

pub close(TcpSocket& socket)
  if socket.alreadyClose == true
    return
    
  socket.alreadyClosed = true
  include
    closeTcp((TcpHandle)_socket->_handle);
