use std

struct ChadFile
  char[] unitName
  char[] srcPath
  List[char[]] headers 

pub struct CLib
  char[] name
  char[] source
  char[][] includes
  List[char[][]] buildCommands
  char[][] libPaths
  char[][] dependsOn

pub struct Exe
  char[] exeName
  char[] description
  List[ChadFile] files
  List[CLib] libs

addChadFileRecursive(DirEntry entry, List[ChadFile]& files, char[] unitName, char[] path) void!
  char[][] headers = []

  if entry.type is Other
    return Ok
  elif entry.type is File
    char[] modName = fileNameWithoutExtension(entry.name)
    char[] filePath = joinPath(path, entry.name)
    ChadFile file = { srcPath = filePath, headers = toList(headers), unitName = "{unitName}.{modName}" }
    add(files, file)
  elif entry.type is Dir
    char[] sourcePath = joinPath(path, entry.name)
    print(sourcePath)
    DirEntry[] entries = try readDir(sourcePath)
    char[] subModName = fileNameWithoutExtension(entry.name)
    for i 0:entries.len
      try addChadFileRecursive(entries[i], files, "{unitName}.{subModName}", sourcePath)

  return Ok

pub exe(char[] name, char[] description, char[] sourcePath) Exe!
  Exe e = { exeName = name, description = description, files = list(), libs = list() }
  DirEntry[] entries = try readDir(sourcePath)
  for i 0:entries.len
    char[] modName = fileName(sourcePath)
    try addChadFileRecursive(entries[i], e.files, modName, sourcePath)
  return e

pub addLib(Exe& exe, CLib clib)
  add(exe.libs, clib)

pub build(Exe exe) void!
  Process compiler = try exec("npm run start -- -o build")
  char[] buildJson = json(exe)
  try write(compiler.stdin, asBytes(buildJson))
  int exitCode = wait(compiler)
  if exitCode < 0
    return Err("could not compile")
  return Ok

pub cLib(char[] name) CLib
  CLib lib
  lib.name = name
  lib.source = ""
  lib.includes = []
  lib.buildCommands = list()
  lib.libPaths = []
  lib.dependsOn = []

  return lib

pub addDefaultDeps(Exe& exe)
  CLib libuv = cLib("libuv")
  libuv.source = "git@github.com:libuv/libuv.git"
  libuv.includes = ["includes"]
  libuv.buildCommands = list()
  libuv.libPaths = [".libs/libuv.a"]
  libuv.dependsOn = []

  CLib async = cLib("async")
  async.source = "lib/async"
  List[char[][]] buildCommands = list(3)
  add(buildCommands, ["clang", "-c", "-o", "async.o", "async.c", "-g", "-I../libuv/includes"])
  add(buildCommands, ["nasm", "-f", "elf64", "x64.s", "-o", "asm.o"])
  add(buildCommands, ["ar", "rcs", "libasync.a", "async.o", "asm.o"])
  async.buildCommands = buildCommands
  async.includes = ["includes"]
  async.libPaths = ["libasync.a"]
  async.dependsOn = ["libuv"]

  add(exe.libs, libuv)
  add(exe.libs, async)

# serialize the exe structure into json and write to stdout
# note this can be fixed once serialization is implemented
pub json(Exe exe) char[]
  StrBuf json = strBuf()
  append(json, '{')

  appendProp(json, "exeName", exe.exeName)
  append(json, ',')

  appendProp(json, "description", exe.description)
  append(json, ',')

  append(json, "\"files\": [")
  for i 0:exe.files.len
    appendChadFile(json, exe.files[i])
    if i != exe.files.len - 1
      append(json, ',')
  append(json, "],")

  append(json, "\"libs\": [")
  for i 0:exe.libs.len
    appendCLib(json, exe.libs[i])
    if i != exe.files.len - 1
      append(json, ',')
  append(json, ']')

  append(json, '}')

  return view(json)

# appends "propName": "propValue"
appendProp(StrBuf& json, char[] propName, char[] propValue)
  append(json, '\"')
  append(json, propName)
  append(json, "\": \"")
  append(json, propValue)
  append(json, '\"')

# appends { ... }
appendChadFile(StrBuf& json, ChadFile file)
  append(json, '{')

  appendProp(json, "unitName", file.unitName)
  append(json, ',')

  appendProp(json, "srcPath", file.srcPath)
  append(json, ',')

  appendPropList(json, "headers", view(file.headers))

  append(json, '}')

# appends [""]
appendPropList(StrBuf& json, char[] listName, char[][] items)
  append(json, "\"{listName}\": [")
  for i 0:items.len
    append(json, '\"')
    append(json, items[i])
    append(json, '\"')
    if i != items.len - 1
      append(json, ',')
  append(json, ']')

appendCharList(StrBuf& json, char[][] items)
  append(json, '[')
  for i 0:items.len
    append(json, '\"')
    append(json, items[i])
    append(json, '\"')
    if i != items.len - 1
      append(json, ',')
  append(json, ']')

# appends "buildCommands": [...]
appendBuildCommands(StrBuf& json, List[char[][]] buildCommands)
  append(json, "\"buildCommands\": [") 
  for i 0:buildCommands.len
    appendCharList(json, buildCommands[i])
    if i != buildCommands.len - 1
      append(json, ',')

  append(json, ']')

# appends { ... }
appendCLib(StrBuf& json, CLib lib)
  append(json, '{')

  appendProp(json, "name", lib.name)
  append(json, ',')

  appendProp(json, "source", lib.source)
  append(json, ',')

  appendPropList(json, "includes", lib.includes)
  append(json, ',')

  appendBuildCommands(json, lib.buildCommands)
  append(json, ',')

  appendPropList(json, "libPaths", lib.libPaths)
  append(json, ',')

  appendPropList(json, "dependsOn", lib.dependsOn)

  append(json, '}')
