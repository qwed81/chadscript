use std

struct ChadFile
  char[] unitName
  char[] srcPath
  List[char[]] headers 

pub struct CLib
  char[] name
  char[] source
  char[][] includes
  char[][] buildCommands
  char[][] libPaths
  char[][] dependsOn

pub struct Exe
  char[] exeName
  char[] description
  List[ChadFile] files
  List[CLib] libs

addChadFileRecursive(DirEntry entry, List[ChadFile]& files, char[] unitName, char[] path) void!
  char[][] headers = []

  if entry.type is Other
    return Ok
  elif entry.type is File
    char[] modName = fileNameWithoutExtension(entry.name)
    char[] filePath = joinPath(path, entry.name)
    ChadFile file = { srcPath = filePath, headers = toList(headers), unitName = "{unitName}.{modName}" }
    add(files, file)
  elif entry.type is Dir
    char[] sourcePath = joinPath(path, entry.name)
    DirEntry[] entries = try readDir(sourcePath)
    char[] subModName = fileNameWithoutExtension(entry.name)
    for i 0:entries.len
      try addChadFileRecursive(entries[i], files, "{unitName}.{subModName}", sourcePath)

  return Ok

pub exe(char[] name, char[] description, char[] sourcePath) Exe!
  Exe e = { exeName = name, description = description, files = list(), libs = list() }
  DirEntry[] entries = try readDir(sourcePath)
  for i 0:entries.len
    char[] modName = fileName(sourcePath)
    try addChadFileRecursive(entries[i], e.files, modName, sourcePath)
  return e

pub addLib(Exe& exe, CLib clib)
  add(exe.libs, clib)

# serialize the exe structure into json and write to stdout
# note this can be fixed once serialization is implemented
pub finalize(Exe exe)
  StrBuf json = strBuf()
  append(json, '{')

  appendProp(json, "exeName", exe.exeName)
  append(json, ',')

  appendProp(json, "description", exe.description)
  append(json, ',')

  append(json, "\"files\": [")
  for i 0:exe.files.len
    appendChadFile(json, exe.files[i])
    if i != exe.files.len - 1
      append(json, ',')
  append(json, "],")

  append(json, "\"libs\": [")
  for i 0:exe.libs.len
    appendCLib(json, exe.libs[i])
    if i != exe.files.len - 1
      append(json, ',')
  append(json, ']')

  append(json, '}')

  print(json)

# appends "propName": "propValue"
appendProp(StrBuf& json, char[] propName, char[] propValue)
  append(json, '\"')
  append(json, propName)
  append(json, "\": \"")
  append(json, propValue)
  append(json, '\"')

# appends { ... }
appendChadFile(StrBuf& json, ChadFile file)
  append(json, '{')

  appendProp(json, "unitName", file.unitName)
  append(json, ',')

  appendProp(json, "srcPath", file.srcPath)
  append(json, ',')

  appendPropList(json, "headers", view(file.headers))

  append(json, '}')

# appends [""]
appendPropList(StrBuf& json, char[] listName, char[][] items)
  append(json, "\"{listName}\": [")
  for i 0:items.len
    append(json, '\"')
    append(json, items[i])
    append(json, '\"')
    if i != items.len - 1
      append(json, ',')
  append(json, ']')

# appends { ... }
appendCLib(StrBuf& json, CLib lib)
  append(json, '{')

  appendProp(json, "name", lib.name)
  append(json, ',')

  appendProp(json, "source", lib.source)
  append(json, ',')

  appendPropList(json, "includes", lib.includes)
  append(json, ',')

  appendPropList(json, "buildCommands", lib.buildCommands)
  append(json, ',')

  appendPropList(json, "libPaths", lib.libPaths)
  append(json, ',')

  appendPropList(json, "dependsOn", lib.dependsOn)

  append(json, '}')
